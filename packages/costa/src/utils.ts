import {
  NpmPackageMetadata,
  NpmPackage,
  PluginSource,
  CondaConfig
} from './index';
import { createReadStream } from 'fs-extra';
import * as tar from 'tar-stream';
import { spawn, SpawnOptions } from 'child_process';
import { createUnzip } from 'zlib';
import * as util from 'util';
import { pipeline } from 'stream';
import { get, RequestPromiseOptions } from 'request-promise';
import LRUCache from './lrucache';
import Debug from 'debug';

const debug = Debug('costa.utils');

export const pipelinePromisify = util.promisify(pipeline);

export interface LogStdio {
  stdout: NodeJS.WritableStream;
  stderr: NodeJS.WritableStream;
  prefix?: string;
}

/**
 * pipe a stream to another one, we fork multi child processes serially here,
 * Readable.pipi() will close the target pipe when end, we should ignore the end event.
 * @param readable child process stdout/stderr
 * @param writable the log stream
 * @param prefix the log prefix
 */
export function pipeLog(readable: NodeJS.ReadableStream, writable: NodeJS.WritableStream, prefix?: string): void {
  let buffer = '';
  readable.on('error', (err) => {
    writable.emit('error', err);
  });
  readable.on('data', (data) => {
    if (prefix) {
      buffer += data.toString();
      const list = buffer.split(/\n|\r/);
      buffer = list.pop();
      list.forEach((log) => {
        writable.write(`${prefix}: ${log}\n`);
      });
    } else {
      writable.write(data);
    }
  });
}

export function selectNpmPackage(metadata: NpmPackageMetadata, source: PluginSource): NpmPackage {
  const { version } = source.schema;
  if (version === 'beta') {
    if (metadata['dist-tags'].beta == null) {
      throw TypeError(`the package "${source.name}" has no beta version.`);
    }
    return metadata.versions[metadata['dist-tags'].beta];
  }
  if (version === 'latest') {
    return metadata.versions[metadata['dist-tags'].latest];
  }
  if (version) {
    // TODO(Yorkie): support version range just like (1.0.x, ^1.0.0, ...)
    return metadata.versions[version];
  }
  return metadata.versions[metadata['dist-tags'].latest];
}

export function spawnAsync(command: string, args: string[], opts: SpawnOptions, stdio: LogStdio): Promise<void> {
  return new Promise((resolve, reject) => {
    opts.stdio = [ null, 'pipe', 'pipe' ];
    opts.detached = false;
    const child = spawn(command, args, opts);
    this.pipeLog(child.stdout, stdio.stdout, stdio.prefix);
    this.pipeLog(child.stderr, stdio.stderr, stdio.prefix);
    child.on('close', (code: number) => {
      code === 0 ? resolve() : reject(new TypeError(`invalid code ${code} from ${command}`));
    });
  });
}

export async function extractPackageJsonFromReadable(readable: NodeJS.ReadableStream, pkgFilename: string): Promise<any> {
  let packageJson = '';
  const extract = tar.extract();
  extract.on('entry', (header, stream, next) => {
    if (header.name === pkgFilename) {
      stream.on('data', (buf) => packageJson += buf);
    }
    stream.once('end', next);
    stream.resume();
  });
  await this.pipelinePromisify(readable, extract);
  return JSON.parse(packageJson);
}

export function fetchPackageJsonFromGit(remote: string, head: string): Promise<any> {
  const child = spawn('git', [
    'archive',
    `--remote=${remote}`,
    head,
    'package.json'
  ]);
  return this.extractPackageJsonFromReadable(child.stdout, 'package.json');
}

export function fetchPackageJsonFromTarball(filename: string): Promise<any> {
  const stream = createReadStream(filename);
  return this.fetchPackageJsonFromTarballStream(stream);
}

export async function fetchPackageJsonFromTarballStream(fileStream: NodeJS.ReadableStream): Promise<any> {
  /**
   * the content of the tarball generated by `npm pack` is a directory named 'package'
   * look at: https://github.com/npm/cli/blob/3e7ed30d6e9211e39bd93ec4e254cc5a2b159947/lib/pack.js#L146
  */
  let packageJson = '';
  const unzip = createUnzip();
  const extract = tar.extract();
  extract.on('entry', (header, stream, next) => {
    if (header.name === 'package/package.json') {
      stream.on('data', (buf) => packageJson += buf);
    }
    stream.once('end', next);
    stream.resume();
  });
  await pipelinePromisify(fileStream, unzip, extract);
  return JSON.parse(packageJson);
}

export function createRequirements(config: CondaConfig): string[] {
  const deps = [];
  for (let k in config.dependencies) {
    const v = config.dependencies[k];
    if (v === '*') {
      deps.push(k);
    } else if (v.startsWith('git+https://') === true) {
      deps.push(v);
    } else {
      deps.push(`${k}==${v}`);
    }
  }
  return deps;
}
// TODO(Yorkie): support config this?
const HTTP_CACHE_LIMIT = 1000;

// TODO(Yorkie): support save caches in disk?
/**
 * The HTTP Cache in memory.
 */
export interface HTTPCache {
  etag: string;
  lastModified: string;
  body: any;
}

/**
 * `HTTPCache` with the uri key.
 */
const httpCacheByURI = new LRUCache<HTTPCache>(HTTP_CACHE_LIMIT);

/**
 * This function uses etag to cache the response body with `HTTPCache`, the cache key is
 * the request uri. (This requires the requested server to support the etag cache control)
 *
 * @param uri The requested uri.
 */
export async function requestHttpGetWithCache(uri: string): Promise<any> {
  const cache = httpCacheByURI.get(uri);
  const options: RequestPromiseOptions = {
    timeout: 15000,
    simple: false,
    resolveWithFullResponse: true
  };
  if (cache?.body) {
    options.headers = {
      'Cache-Control': 'max-age=0',
      'If-Modified-Since': cache?.lastModified,
      'If-None-Match': cache?.etag ? `W/${cache.etag}` : undefined
    };
  }
  const resp = await get(uri, options);
  if (resp.statusCode === 200) {
    const body = JSON.parse(resp.body);
    httpCacheByURI.put(uri, {
      etag: resp.headers.etag,
      lastModified: resp.headers['last-modified'],
      body
    });
    return body;
  } else if (resp.statusCode === 304) {
    debug(`using cached response for ${uri}.`);
    return cache.body;
  } else {
    throw new TypeError(resp.message);
  }
}
